using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Xml;
using System.Text.RegularExpressions;
using System.Net;
using System.Diagnostics;
using OsmSharp.Osm.PBF.Streams;
using OsmSharp.Osm;

namespace HouseNumberValidator
{
    class Program
    {
        bool map = false;

        Reports reps = new Reports();

        string dirIn = @"D:\OSM\Data\Dump\";
        string dirOut = @"D:\OSM\Data\Dump\log\";
        string dirOutTemp = @"D:\OSM\Data\Dump\log\temp\";
        string dirOutMap = @"D:\OSM\Data\Dump\log\map\";
        FileInfo file;

        List<string> keys = new List<string>{
				"highway",
				"amenity",
				"place",
				"waterway",
				"shop",
				"natural",
				"landuse",
				"religion",
				"boundary",
                "railway",
                "route",
                "tourism",
                "power",
                "historic",
                "route_master",
                "public_transport",
                "office",
                "traffic_sign",
                "aeroway",
                "craft",
                "leisure",
                "emergency",
                "man_made",
                "social_facility"
			};
        Dictionary<string, string> tags = new Dictionary<string, string>{
                { "associatedStreet", "type" },
                { "collection", "type" },
                { "train_station", "building" }
            };
        List<string> addrkeys = new List<string>{
				"addr:street",
				"addr:place",
                //"addr:quarter",
                //"addr:neighbourhood",
                "is_in:neighbourhood"
			};

        List<HouseNumb> errors;
        List<HouseNumb> warns;
        List<HouseNumb> flats;
        List<HouseNumb> nostreets;
        List<HouseNumb> names;

        List<HouseNumb> schools;
        List<HouseNumb> schoolsDouble;

        List<HouseNumb> members;
        List<NdCoord> nds;
        List<WayCoord> ways;

        DateTime dateDump;

        public void Validate()
        {
            map = true;

            DownloadFiles();
            //ReadFiles();
            //SaveIndexReport();
            //SaveMapAll();

            //Console.WriteLine( nds.Count );
            Console.WriteLine( "End." );
            Console.ReadLine();
        }

        private string[] GetDownFiles( int n = 12 )
        {
            //return reps.Reps.OrderBy( x => x.Stamp ).Take( n ).Select( x => x.Region ).ToArray();

            var r = reps.Reps;
            var minDate = r.Min( x => x.Stamp );
            int firsIndex = 0;

            for ( int i = 0; i < r.Count; i++ )
            {
                if ( r[ i ].Stamp > minDate )
                    continue;

                if ( i > 0 && r[ i - 1 ].Stamp == minDate )
                    continue;

                if ( r[ i ].Stamp == minDate )
                    firsIndex = i;
            }

            var res = r.Skip( firsIndex ).Take( n );
            var count = res.Count();

            if ( count < n )
                res = res.Concat( r.Take( n - count ) );

            var result = res.Select( x => x.Region ).ToArray();

            return result;
        }

        public void DownloadFiles( bool pbf = true )
        {
            string[] regions = GetDownFiles( 30 );
            //string[] regions = { /* "RU-TVE", "RU-RYA", "RU-SAM", "RU-AD", "RU-AL", "RU-ALT", "RU-AMU", */"RU-KYA" };

            string typefile = pbf ? ".osm.pbf" : ".osm.bz2";
            WebClient webClient = new WebClient();

            foreach ( string region in regions )
            {
                Console.Write( "Download {0}", region );
                webClient.DownloadFile( @"http://data.gis-lab.info/osm_dump/dump/latest/" + region + typefile,
                    dirIn + region + typefile + ".down" );
                File.Delete( dirIn + region + typefile );
                File.Move( dirIn + region + typefile + ".down", dirIn + region + typefile );

                file = new FileInfo( dirIn + region + typefile );
                dateDump = file.LastWriteTime;

                Console.CursorLeft = 0;
                Console.Write( "Validate {0}", region );

                Stopwatch stw = new Stopwatch();
                stw.Start();
                if ( pbf )
                    ReadPbfFile( file );
                else
                    ReadBz2File( file );
                stw.Stop();
                //Console.WriteLine( stw.Elapsed );

                WriteReports();
                UploadToFtp();
            }
        }

        public void ReadFiles( bool pbf = true )
        {
            string typefile = pbf ? ".osm.pbf" : ".osm.bz2";

            if ( !Directory.Exists( dirOut ) )
                Directory.CreateDirectory( dirOut );

            foreach ( string fl in Directory.GetFiles( dirIn, "*" + typefile ) )
            {
                file = new FileInfo( fl );
                string region = file.Name.Split( '.' )[ 0 ];
                DateTime stump = reps.GetRegion( region ).Stamp;
                /*
                if (stump.Day >= fileInfo.LastWriteTime.Day 
                    && stump.Month >= fileInfo.LastWriteTime.Month 
                    && stump.Year >= fileInfo.LastWriteTime.Year 
                    )
                    continue;
                */
                if ( region != "RU-TA" ) continue;
                //if ( reps.GetRegion( region ).Warnings == 0 ) continue;

                dateDump = file.LastWriteTime;

                Console.CursorLeft = 0;
                Console.Write( "Validate {0}", region );

                Stopwatch stw = new Stopwatch();
                stw.Start();
                if ( pbf )
                    ReadPbfFile( file );
                else
                    ReadBz2File( file );
                stw.Stop();
                Console.WriteLine( stw.Elapsed );

                WriteReports();
            }
        }

        private void WriteReports()
        {
            string descWarns = "";
            string descFlats = "Не правильно обозначенные номера квартир в подъезде.<br>"
                + "Правильный формат записи addr:flats=3-7;10;14;16-18<br>";
            string descNoStreets = "Список номеров домов без \"addr:street\" и \"addr:place\"<br>";
            string descNames = "Список объектов с name, у которых нет ни одного из данных тегов: "
                + "highway, amenity, place, waterway, shop, natural, landuse, religion, boundary, "
                + "railway, route, tourism, power, historic, route_master, public_transport, office, "
                + "traffic_sign, aeroway, craft, leisure, emergency, man_made, social_facility.<br>"
                + "Например: есть объект с name=\"Школа №2\", но нет тега amenity=school.<br>"
                + "В колонке с дополнительной информацией перечислены все ключи данного объкта.<br>";

            string region = file.Name.Split( '.' )[ 0 ];
            Console.CursorLeft = 0;
            Console.WriteLine( "{0}:\t{1,4} err, {2,5} warn, {3,3} flats, {4,4} strt, {5,5} names", region,
                errors.Count,
                warns.Count,
                flats.Count,
                nostreets.Count,
                names.Count );
            //Console.WriteLine( "{0} flats", flats.Count );
            reps.Edit( new RegionReport( region, errors.Count, warns.Count, flats.Count, nostreets.Count, names.Count, schoolsDouble.Count, dateDump ) );
            //SaveMapHtml();
            SaveReport( new FileInfo( dirOut + region + ".html" ), errors.OrderByDescending( x => x.TimeStump ).ToList() );
            SaveReport( new FileInfo( dirOut + region + ".warning.html" ), warns.OrderByDescending( x => x.TimeStump ).ToList() );
            SaveReport( new FileInfo( dirOut + region + ".flats.html" ), flats.OrderByDescending( x => x.TimeStump ).ToList(), descFlats );
            SaveReport( new FileInfo( dirOut + region + ".nostreet.html" ), nostreets.OrderByDescending( x => x.TimeStump ).OrderBy( x => x.Description ).ToList(), descNoStreets );
            SaveReport( new FileInfo( dirOut + region + ".names.html" ), names.OrderBy(x=>x.Hnumb).ToList(), descNames );
            if ( map )
            {
                SaveMapHtml( new FileInfo( dirOutMap + region + ".errors.map.html" ), errors );
                SaveMapHtml( new FileInfo( dirOutMap + region + ".warning.map.html" ), warns );
                SaveMapHtml( new FileInfo( dirOutMap + region + ".nostreet.map.html" ), nostreets );
                SaveMapHtml( new FileInfo( dirOutMap + region + ".names.map.html" ), names );

                SaveMapHtml( new FileInfo( dirOutMap + region + ".double.map.html" ), schoolsDouble );
            }
            SaveIndexReport();
        }

        public void ReadPbfFile( FileInfo pbfile )
        {
            errors = new List<HouseNumb>();
            warns = new List<HouseNumb>();
            names = new List<HouseNumb>();
            flats = new List<HouseNumb>();
            nostreets = new List<HouseNumb>();
            members = new List<HouseNumb>();

            schools = new List<HouseNumb>();
            schoolsDouble = new List<HouseNumb>();

            nds = null;
            ways = null;
            GC.Collect( 2, GCCollectionMode.Forced, true );

            nds = new List<NdCoord>( 20000000 );
            ways = new List<WayCoord>( 2000000 );
            //List<Task> ts = new List<Task>();

            using ( FileStream fileStream = pbfile.OpenRead() )
            {
                PBFOsmStreamSource reader = new PBFOsmStreamSource( fileStream );
                foreach ( var osmGeo in reader )
                {
                    if ( osmGeo.Id.HasValue )
                        ParsePbfElement( osmGeo );
                }
            }

            ValidateDoubleTag();
            nostreets = nostreets.Except( members, new HouseNumbComparer() ).ToList();
            nostreets = nostreets.OrderBy( x => x.Description ).ToList();
        }

        private void ValidateDoubleTag()
        {
            double square = 0.0015;
            StringComparison nocs = StringComparison.OrdinalIgnoreCase;

            schools = schools.OrderBy( x => x.lat ).ToList();
            for ( int i = 0; i < schools.Count - 1; i++ )
            {
                var refi = new string( schools[ i ].Hnumb.Where( x => Char.IsDigit( x ) ).ToArray() );
                var containi = schools[ i ].Hnumb.IndexOf( "школа", nocs ) >= 0 || schools[ i ].Hnumb.IndexOf( "сош", nocs ) >= 0;

                for ( int j = i + 1; j < schools.Count; j++ )
                {
                    if ( Math.Abs( schools[ i ].lat - schools[ j ].lat ) > square )
                        break;
                    if ( Math.Abs( schools[ i ].lon - schools[ j ].lon ) > square )
                        continue;

                    var refj = new string( schools[ j ].Hnumb.Where( x => Char.IsDigit( x ) ).ToArray() );
                    var containj = schools[ j ].Hnumb.IndexOf( "школа", nocs ) >= 0 || schools[ j ].Hnumb.IndexOf( "сош", nocs ) >= 0;

                    if ( refi == refj ||
                        ( ((containi && refi == string.Empty ) || schools[ i ].Hnumb == string.Empty ) && refj != string.Empty ) ||
                        ( refi != string.Empty && ( ( refj == string.Empty && containj ) || schools[ j ].Hnumb == string.Empty ) )
                        )
                    {
                        schoolsDouble.Add( schools[ i ] );
                        schoolsDouble.Add( schools[ j ] );
                    }
                }
            }
            schoolsDouble = schoolsDouble.Distinct().ToList();
        }
        
        private void ParsePbfElement( OsmGeo geo )
        {
            long id = (long)geo.Id;
            string type = geo.Type == OsmGeoType.Node ? "node" : geo.Type == OsmGeoType.Way ? "way" : "relation";
            DateTime tstamp = (DateTime)geo.TimeStamp;

            //dateDump = (DateTime)geo.TimeStamp > dateDump ? (DateTime)geo.TimeStamp : dateDump;

            if ( geo.Type == OsmGeoType.Node )
            {
                try
                {
                    nds.Add( new NdCoord( id, ( (Node)geo ).Coordinate.Latitude, ( (Node)geo ).Coordinate.Longitude )  );
                }
                catch ( OutOfMemoryException ex )
                { }
            }
            if ( geo.Type == OsmGeoType.Way )
            {
                try
                {
                    ways.Add( new WayCoord( id, ( (Way)geo ).Nodes[ 0 ] ) );
                }
                catch ( OutOfMemoryException ex )
                { }
            }

            string value;

            if ( geo.Type == OsmGeoType.Relation && geo.Tags.ContainsKeyValue( "type", "associatedStreet" ) )
            {
                Relation rel = (Relation)geo;
                foreach ( var m in rel.Members )
                {
                    if ( m.MemberRole == "house" )
                    {
                        string mtype = m.MemberType == OsmGeoType.Node ? "node" : m.MemberType == OsmGeoType.Way ? "way" : "relation";
                        members.Add( new HouseNumb( mtype, (long)m.MemberId ) );
                    }
                }
            }
            for ( int i = 1; i <= 9; i++ )
            {
                if ( geo.Tags.TryGetValue( String.Format( "addr{0}:housenumber", i > 1 ? i.ToString() : "" ), out value ) )
                {
                    if ( !CountryRu( geo ) )
                        continue;

                    HouseNumb error = new HouseNumb( type, id, value, tstamp );
                    if ( !ValidateHouseNumbOnError( error ) )
                    {
                        GetCoordinates( geo, error );
                        errors.Add( error );
                    }
                    if ( !ValidateHouseNumbOnWarn( error ) )
                    {
                        if ( error.lat == 0.0 )
                            GetCoordinates( geo, error );
                        warns.Add( error );
                    }
                    error.Description += GetNotes( geo.Tags );

                    if ( i == 1 && !geo.Tags.ContainsOneOfKeys( addrkeys ) )
                    {
                        HouseNumb nostreet = new HouseNumb( type, id, value, tstamp );
                        string city;
                        if ( geo.Tags.TryGetValue( "addr:city", out city ) )
                            nostreet.Description += "<font color=\"gray\">city:</font> " + city;
                        if ( geo.Tags.TryGetValue( "addr:suburb", out city ) )
                            if ( nostreet.Description != String.Empty)
                                nostreet.Description += "  |  " + "<font color=\"gray\">suburb: </font>" + city;
                            else
                                nostreet.Description += "<font color=\"gray\">suburb: </font>" + city;
                        GetCoordinates( geo, nostreet );
                        nostreets.Add( nostreet );
                    }
                }
                else
                    break;
            }
            if ( geo.Tags.TryGetValue( "name", out value ) )
            {
                HouseNumb name = new HouseNumb( type, id, value, tstamp );

                if ( !ValidateVoidNames( geo ) )
                {
                    
                    string alltags = "";
                    foreach ( var tg in geo.Tags )
                    {
                        if ( !tg.Key.StartsWith( "addr" ) && !tg.Key.StartsWith( "building:" ) && !tg.Key.StartsWith( "name" ) )
                            alltags += tg.Key + " | ";
                    }
                    name.Description += alltags.TrimEnd( new char[ 2 ] { '|', ' ' } ) + "<br>";

                    GetCoordinates( geo, name );
                    names.Add( name );
                }
            }
            if ( geo.Tags.TryGetValue( "addr:flats", out value ) )
            {
                HouseNumb flat = new HouseNumb( type, id, value, tstamp );
                if ( !ValidateFlats( flat ) )
                {
                    GetCoordinates( geo, flat );
                    flats.Add( flat );
                }
            }

            if ( geo.Tags.ContainsKeyValue("amenity","school") )
            {
                geo.Tags.TryGetValue( "name", out value );
                var school = new HouseNumb( type, id, value );
                GetCoordinates( geo, school );
                schools.Add( school );
            }
        }

        private string GetNotes( OsmSharp.Collections.Tags.TagsCollectionBase tags )
        {
            string result = "";
            foreach ( var tag in tags )
            {
                if ( tag.Key == "note" )
                {
                    result += "<b>Note:</b> " + tag.Value + "<br>";
                    continue;
                }
                if ( tag.Key == "fixme" )
                {
                    result += "<b>FixMe:</b> " + tag.Value + "<br>";
                    continue;
                }
                if ( tag.Key == "description" )
                {
                    result += "<b>Description:</b> " + tag.Value + "<br>";
                    continue;
                }
            }
            return result;
        }

        private void GetCoordinates( OsmGeo geo, HouseNumb res )
        {
            if ( map && geo.Type == OsmGeoType.Node )
            {
                res.lat = ( (Node)geo ).Coordinate.Latitude;
                res.lon = ( (Node)geo ).Coordinate.Longitude;
            }
            else if ( map && geo.Type == OsmGeoType.Way )
            {
                long ndid = ( (Way)geo ).Nodes[ 0 ];
                GetCoordinatesNode( ndid, res );
            }
            else if ( map && geo.Type == OsmGeoType.Relation )
            {
                var member = ( (Relation)geo ).Members[0];
                if ( member.MemberType == OsmGeoType.Node )
                {
                    long ndid = (long)member.MemberId;
                    GetCoordinatesNode( ndid, res );
                }
                if ( member.MemberType == OsmGeoType.Way )
                {
                    long ndid = (long)member.MemberId;
                    GetCoordinatesWay( ndid, res );
                }
            }
        }
        private void GetCoordinatesNode( long id, HouseNumb res )
        {
            int i = nds.BinarySearch( new NdCoord( id, 0.0, 0.0 ) );
            if ( i >= 0 )
            {
                NdCoord nd = nds[ i ];
                res.lat = nd.lat;
                res.lon = nd.lon;
            }
        }
        private void GetCoordinatesWay( long id, HouseNumb res )
        {
            int w = ways.BinarySearch( new WayCoord( id, 0 ) );
            if ( w >= 0 )
            {
                long ndid = ways[ w ].ndId;
                GetCoordinatesNode( ndid, res );
            }
        }

        //private async void ReadFile( FileInfo bzfile )
        private void ReadBz2File( FileInfo bzfile )
        {
            errors = new List<HouseNumb>();
            warns = new List<HouseNumb>();
            List<Task> ts = new List<Task>();

            using ( FileStream fileStream = bzfile.OpenRead() )
            {
                using ( Stream unzipStream = new ICSharpCode.SharpZipLib.BZip2.BZip2InputStream( fileStream ) )
                {
                    XmlReader xmlReader = XmlReader.Create( unzipStream );

                    while ( xmlReader.Read() )
                    {
                        if ( xmlReader.Name == "node" || xmlReader.Name == "way" || xmlReader.Name == "relation" )
                        {
                            //Task t = ParseOsmElement( xmlReader.ReadOuterXml() );
                            //t.Wait();
                            //ts.Add( t );
                            //await ParseOsmElement( xmlReader.ReadOuterXml() );
                            ParseBz2Element( xmlReader.ReadOuterXml() );
                        }
                    }
                }
            }
        }

        //private async Task ParseOsmElement( string xml )
        private void ParseBz2Element( string xml )
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml( xml );

            long id = Int64.Parse( xmlDoc.DocumentElement.Attributes[ "id" ].Value );
            string type = xmlDoc.DocumentElement.Name;

            HouseNumb toValidate = new HouseNumb( type, id );
            bool hnumb = false;

            foreach ( XmlNode tag in xmlDoc.DocumentElement.ChildNodes )
            {
                if ( tag.Name == "tag" )
                {
                    if ( tag.Attributes[ "k" ].Value == "addr:housenumber" )
                    {
                        toValidate.Hnumb = tag.Attributes[ "v" ].Value;
                        hnumb = true;
                    }
                    if ( tag.Attributes[ "k" ].Value == "note" )
                    {
                        toValidate.Description += "<b>Note:</b> " + tag.Attributes[ "v" ].Value + "<br>";
                    }
                    if ( tag.Attributes[ "k" ].Value == "fixme" )
                    {
                        toValidate.Description += "<b>FixMe:</b> " + tag.Attributes[ "v" ].Value + "<br>";
                    }
                    if ( tag.Attributes[ "k" ].Value == "description" )
                    {
                        toValidate.Description += "<b>Description:</b> " + tag.Attributes[ "v" ].Value + "<br>";
                    }
                }
            }

            if ( hnumb && !ValidateHouseNumbOnError( toValidate ) )
                errors.Add( toValidate );
        }

        private bool CountryRu( OsmGeo geo )
        {
            string country;
            if ( geo.Tags.TryGetValue( "addr:country", out country ) && country != "RU" )
                return false;

            string street;
            if ( geo.Tags.TryGetValue( "addr:street", out street ) )
            {
                bool ru = false;
                foreach ( var ch in street )
                    if ( ( ch >= 'а' && ch <= 'я' ) || ( ch >= 'А' && ch <= 'Я' ) )
                    {
                        ru = true;
                        break;
                    }
                if ( !ru )
                    return false;
            }
            if ( geo.Tags.TryGetValue( "addr:city", out street ) )
            {
                bool ru = false;
                foreach ( var ch in street )
                    if ( ( ch >= 'а' && ch <= 'я' ) || ( ch >= 'А' && ch <= 'Я' ) )
                    {
                        ru = true;
                        break;
                    }
                if ( !ru )
                    return false;
            }
            if ( geo.Tags.TryGetValue( "addr:place", out street ) )
            {
                bool ru = false;
                foreach ( var ch in street )
                    if ( ( ch >= 'а' && ch <= 'я' ) || ( ch >= 'А' && ch <= 'Я' ) )
                    {
                        ru = true;
                        break;
                    }
                if ( !ru )
                    return false;
            }

            return true;
        }

        private bool ValidateHouseNumbOnWarn( HouseNumb hn )
        {
            Match downRes = Regexes.down.Match( hn.Hnumb );
            if ( downRes.Success && downRes.Length == hn.Hnumb.Length )
            {
                hn.Description += "После номера дложна быть заглавная буква: ";
                hn.Description += downRes.Groups[ 1 ] + downRes.Groups[ 2 ].Value.ToUpper() + downRes.Groups[ 3 ] + "<br>";
                return false;
            }

            return true;
        }

        private bool ValidateHouseNumbOnError( HouseNumb hn )
        {
            if ( Regexes.CheckPattern( Regexes.numb, hn.Hnumb ) )
                return true;

            if ( Regexes.CheckPattern( Regexes.defis, hn.Hnumb ) )
                return true;

            if ( Regexes.CheckPattern( Regexes.nch, hn.Hnumb ) )
                return true;

            if ( Regexes.CheckPattern( Regexes.rim, hn.Hnumb ) )
                return true;

            if ( Regexes.CheckPattern( Regexes.zyab, hn.Hnumb ) )
                return true;

            if ( Regexes.CheckPattern( Regexes.c, hn.Hnumb ) )
                return true;

            if ( Regexes.CheckPattern( Regexes.zgrad, hn.Hnumb ) )
                return true;
            
            if ( Regexes.MatchSuccess( Regexes.latin, hn.Hnumb ) )
                hn.Description += "Содержится английская буква<br>";

            if ( Regexes.CheckPattern( Regexes.space, hn.Hnumb ) )
                hn.Description += "Пробел между номером и буквой, надо: " + Regexes.space.Replace( hn.Hnumb, Regexes.spaceReplace ).ToUpper() + "<br>";

            if ( Regexes.CheckPattern( Regexes.korp, hn.Hnumb ) )
            {
                hn.Description += "Неверно обозначен корпус, надо: " + Regexes.korp.Replace( hn.Hnumb, Regexes.korpReplace ) + "<br>";
                //hn.FixHnumb = korp.Replace( hn.FixHnumb != "" ? hn.FixHnumb : hn.Hnumb, korpReplace );
            }

            if ( Regexes.CheckPattern( Regexes.stroy, hn.Hnumb ) )
            {
                hn.Description += "Неверно обозначено строение, надо: " + Regexes.stroy.Replace( hn.Hnumb, Regexes.stroyReplace ) + "<br>";
                //hn.FixHnumb = korp.Replace( hn.FixHnumb != "" ? hn.FixHnumb : hn.Hnumb, korpReplace );
            }

            if ( Regexes.CheckPattern( Regexes.soor, hn.Hnumb ) )
                hn.Description += "Неверно обозначено сооружение, надо: " + Regexes.soor.Replace( hn.Hnumb, Regexes.soorReplace ) + "<br>";
            
            //------------------------------------------
            /*
            Match latinRes = latin.Match( hn.Hnumb );
            if ( latinRes.Success )
                hn.Description += "Содержится английская буква<br>";

            Match spaceRes = space.Match( hn.Hnumb );
            if ( spaceRes.Success && spaceRes.Length == hn.Hnumb.Length )
                hn.Description += "Пробел между номером и буквой, надо: " + space.Replace( hn.Hnumb, spaceReplace ).ToUpper() + "<br>";

            Match fullRes = full.Match( hn.Hnumb );
            if ( fullRes.Success && fullRes.Length == hn.Hnumb.Length )
            {
                string result = "";
                if ( fullRes.Groups[ 1 ].Success )
                {
                    hn.Description += "Неверно обозначено:";
                    result += fullRes.Groups[ 1 ].Value;
                }
                if ( fullRes.Groups[ 2 ].Success )
                {
                    hn.Description += " корпус";
                    result += " к" + fullRes.Groups[ 2 ].Value;
                }
                if ( fullRes.Groups[ 3 ].Success )
                {
                    hn.Description += " строение";
                    result += " с" + fullRes.Groups[ 3 ].Value;
                }
                if ( fullRes.Groups[ 4 ].Success )
                {
                    hn.Description += " сооружение";
                    result += " соор" + fullRes.Groups[ 4 ].Value;
                }
                hn.Description += ". Надо: <b>" + result + "</b>";

                //hn.FixHnumb = korp.Replace( hn.FixHnumb != "" ? hn.FixHnumb : hn.Hnumb, korpReplace );
            }
            */

            return false;
        }

        /*
        private bool ValidateHouseNumbOnError( HouseNumb hn )
        {
            Match res = numb.Match( hn.Hnumb );
            if ( res.Success && res.Length == hn.Hnumb.Length )
                return true;

            Match defisRes = defis.Match( hn.Hnumb );
            if ( defisRes.Success && defisRes.Length == hn.Hnumb.Length )
                return true;

            Match nchRes = nch.Match( hn.Hnumb );
            if ( nchRes.Success && nchRes.Length == hn.Hnumb.Length )
                return true;

            Match rimRes = rim.Match( hn.Hnumb );
            if ( rimRes.Success && rimRes.Length == hn.Hnumb.Length )
                return true;

            Match zyabRes = zyab.Match( hn.Hnumb );
            if ( zyabRes.Success && zyabRes.Length == hn.Hnumb.Length )
                return true;

            Match cRes = c.Match( hn.Hnumb );
            if ( cRes.Success && cRes.Length == hn.Hnumb.Length )
                return true;

            Match zgradRes = zgrad.Match( hn.Hnumb );
            if ( zgradRes.Success && zgradRes.Length == hn.Hnumb.Length )
                return true;

            Match latinRes = latin.Match( hn.Hnumb );
            if ( latinRes.Success )
                hn.Description += "Содержится английская буква<br>";

            Match spaceRes = space.Match( hn.Hnumb );
            if ( spaceRes.Success && spaceRes.Length == hn.Hnumb.Length )
                hn.Description += "Пробел между номером и буквой, надо: " + space.Replace( hn.Hnumb, spaceReplace ).ToUpper() + "<br>";

            Match korpRes = korp.Match( hn.Hnumb );
            if ( korpRes.Success && korpRes.Length == hn.Hnumb.Length )
            {
                hn.Description += "Неверно обозначен корпус, надо: " + korp.Replace( hn.Hnumb, korpReplace ) + "<br>";
                //hn.FixHnumb = korp.Replace( hn.FixHnumb != "" ? hn.FixHnumb : hn.Hnumb, korpReplace );
            }

            Match stroyRes = stroy.Match( hn.Hnumb );
            if ( stroyRes.Success && stroyRes.Length == hn.Hnumb.Length )
            {
                hn.Description += "Неверно обозначено строение, надо: " + stroy.Replace( hn.Hnumb, stroyReplace ) + "<br>";
                //hn.FixHnumb = korp.Replace( hn.FixHnumb != "" ? hn.FixHnumb : hn.Hnumb, korpReplace );
            }

            Match soorRes = soor.Match( hn.Hnumb );
            if ( soorRes.Success && soorRes.Length == hn.Hnumb.Length )
                hn.Description += "Неверно обозначено сооружение, надо: " + soor.Replace( hn.Hnumb, soorReplace ) + "<br>";

            //------------------------------------------
            
            Match latinRes = latin.Match( hn.Hnumb );
            if ( latinRes.Success )
                hn.Description += "Содержится английская буква<br>";

            Match spaceRes = space.Match( hn.Hnumb );
            if ( spaceRes.Success && spaceRes.Length == hn.Hnumb.Length )
                hn.Description += "Пробел между номером и буквой, надо: " + space.Replace( hn.Hnumb, spaceReplace ).ToUpper() + "<br>";

            Match fullRes = full.Match( hn.Hnumb );
            if ( fullRes.Success && fullRes.Length == hn.Hnumb.Length )
            {
                string result = "";
                if ( fullRes.Groups[ 1 ].Success )
                {
                    hn.Description += "Неверно обозначено:";
                    result += fullRes.Groups[ 1 ].Value;
                }
                if ( fullRes.Groups[ 2 ].Success )
                {
                    hn.Description += " корпус";
                    result += " к" + fullRes.Groups[ 2 ].Value;
                }
                if ( fullRes.Groups[ 3 ].Success )
                {
                    hn.Description += " строение";
                    result += " с" + fullRes.Groups[ 3 ].Value;
                }
                if ( fullRes.Groups[ 4 ].Success )
                {
                    hn.Description += " сооружение";
                    result += " соор" + fullRes.Groups[ 4 ].Value;
                }
                hn.Description += ". Надо: <b>" + result + "</b>";

                //hn.FixHnumb = korp.Replace( hn.FixHnumb != "" ? hn.FixHnumb : hn.Hnumb, korpReplace );
            }
            

            return false;
        }
         */

        private bool ValidateVoidNames( OsmGeo geo )
        {
            if ( geo.Tags.ContainsOneOfKeys( keys ) )
                return true;

            foreach ( var tag in tags )
                if ( geo.Tags.ContainsKeyValue( tag.Value, tag.Key ) )
                    return true;

            return false;
        }

        private bool ValidateVoidNames( HouseNumb hn, OsmGeo geo )
        {
            StringComparison nocs = StringComparison.OrdinalIgnoreCase;
            if ( geo.Tags.ContainsOneOfKeys( keys ) )
                return true;

            string value;
            geo.Tags.TryGetValue( "name", out value );
            /*
            if ( value.IndexOf( "азс", nocs ) >= 0 || value.IndexOf( "заправ", nocs ) >= 0 )
            {
                hn.Description += "Автозаправка<br>";
                return false;
            }
            if ( value.IndexOf( "школа", nocs ) >= 0 || value.IndexOf( "сош", nocs ) >= 0 )
            {
                hn.Description += "Школа<br>";
                return false;
            }
            if ( value.IndexOf( "доу", nocs ) >= 0 || value.IndexOf( "сад", nocs ) >= 0 )
            {
                hn.Description += "Детский сад<br>";
                return false;
            }*/
            if ( value.IndexOf( "молочная кухня", nocs ) >= 0 )
            {
                hn.Description += @"amenity=<a href=""http://wiki.openstreetmap.org/wiki/RU:Key:social_facility"">social_facility</a> & social_facility=dairy_kitchen<br>";
                return false;
            }
            if ( value.IndexOf( "детский сад", nocs ) >= 0 || value.IndexOf( "д/с", nocs ) >= 0 )
            {
                hn.Description += @"amenity=<a href=""http://wiki.openstreetmap.org/wiki/Tag:amenity%3Dkindergarten"">kindergarten</a><br>";
                return false;
            }

            foreach ( var tag in tags )
                if ( geo.Tags.ContainsKeyValue( tag.Value, tag.Key ) )
                    return true;

            return false;
        }

        private bool ValidateFlats( HouseNumb hn )
        {
            if ( Regexes.CheckPattern( Regexes.flat, hn.Hnumb ) )
                return true;

            if ( hn.Hnumb.Contains( ',' ) )
                hn.Description += "Заменить ',' на ';'";

            return false;
        }

        private void SaveReport( FileInfo outfile, List<HouseNumb> lst )
        {
            SaveReport( outfile, lst, "" );
        }

        private void SaveReport( FileInfo outfile, List<HouseNumb> lst, string description)
        {
            using ( StreamWriter fw = new StreamWriter( outfile.FullName, false, Encoding.UTF8 ) )
            {
                string regShort = outfile.Name.Split( '.' )[ 0 ];
                string region = Regions.RegionsDict[ regShort ];

                //var regInf = reps.Reps.First( x => x.Region == regShort );

                fw.WriteLine( @"<html><head>" );
                fw.WriteLine( @"<title>{0}</title>", region );

                fw.WriteLine( @"<style type=""text/css"">" );
                fw.WriteLine( @"</style>" );
                fw.WriteLine( @"<link rel=""stylesheet"" href=""style/style.css"" />" );
                fw.WriteLine( @"</head>" );

                fw.WriteLine( @"<body>" );
                fw.WriteLine( @"<img id=josm width=1 height=1 border=0 style='display:none' />" );

                fw.WriteLine( @"<script><!--" );
                fw.WriteLine( @"function open_josm(x) { document.getElementById('josm').src='http://127.0.0.1:8111/load_object?objects='+x; }" );
                fw.WriteLine( @"--></script>" );

                string elements = "";
                bool zapytaya = false;
                foreach ( HouseNumb pl in lst )
                {
                    if ( zapytaya )
                        elements += ",";
                    else
                        zapytaya = true;
                    elements += pl.Type + pl.Osmid;
                }

                fw.WriteLine( @"<b>{1}</b> | Дата проверки: {0:d MMM yyyy} | Ошибок: {2}<br>",
                    dateDump,
                    region,
                    lst.Count 
                    );

                if ( description != string.Empty )
                    fw.WriteLine( "<br>" + description + "<br>" );

                fw.WriteLine( @"<table>" );
                fw.Write( @"<tr>" );
                fw.Write( @"<td>" );
                fw.Write( @"<a href=""http://127.0.0.1:8111/load_object?objects=" );
                fw.Write( elements );
                fw.Write( @""" onClick=""open_josm('" );
                fw.Write( elements );
                fw.Write( @"');return false;""><img border=0 width=20 height=20 src=icon_josm_all.png></a>" );
                fw.Write( @"</td>" );
                fw.Write( @"<td><b>Ошибка</b></td>" );
                fw.Write( @"<td><b>Доп. информация</b></td>" );
                fw.Write( @"</tr>" );
                fw.WriteLine();

                int n = 0;
                foreach ( HouseNumb pl in lst )
                {
                    if ( n++ % 2 == 1 )
                        fw.Write( @"<tr>" );
                    else
                        fw.Write( @"<tr class=""clr"">" );
                    fw.Write( @"<td><a href=""http://127.0.0.1:8111/load_object?objects={0}{1}"" onClick=""open_josm('{0}{1}');return false;""><img src=icon_to_josm.png></a></td>", pl.Type, pl.Osmid );
                    fw.Write( @"<td><a href=""http://osm.org/{0}/{1}"">{2}</a></td>", pl.Type, pl.Osmid, pl.Hnumb );
                    fw.Write( @"<td>" + pl.Description + @"</td>" );
                    fw.Write( @"</tr>" );
                    fw.WriteLine();
                }

                fw.WriteLine( @"</table>" );
                fw.WriteLine( @"</body></html>" );
            }
        }

        public void SaveIndexReport()
        {
            string outFileName = "v.html";
            using ( StreamWriter fw = new StreamWriter( dirOut + outFileName, false, Encoding.UTF8 ) )
            {
                fw.WriteLine( @"<html><head>" );
                fw.WriteLine( @"<title>Валидатор номеров домов</title>" );
                fw.WriteLine( @"<style type=""text/css"">" );
                fw.WriteLine( @"TR.clr {background: #eeeeee}" );
                fw.WriteLine( @"TD {padding: 0px 7px}" );
                //fw.WriteLine( @"* { font-family:'Colibri'; }" );
                fw.WriteLine( @"</style></head>" );

                fw.WriteLine( @"<body>" );
                fw.WriteLine( @"<b>Валидатор номеров домов</b> | " );
                fw.WriteLine( @"<a href=""http://forum.openstreetmap.org/viewtopic.php?id=53343"">Форум</a>" );
                fw.Write( @" | " );
                fw.WriteLine( @"<a href=""http://wiki.openstreetmap.org/wiki/RU:Валидаторы"">Другие валидаторы</a>" );
                fw.Write( @"<br><br>" );
                fw.WriteLine( @"<table>" );
                fw.Write( @"<tr>" );
                fw.Write( @"<td><b>Регион</b></td>" );
                fw.Write( @"<td><b>Дата проверки</b></td>" );
                fw.Write( @"<td><b>Ошибки</b></td>" );
                fw.Write( @"<td><b>Пред-ия</b></td>" );
                fw.Write( @"<td><b>Квартиры</b></td>" );
                fw.Write( @"<td><b>Нет улицы</b></td>" );
                fw.Write( @"<td><b>Нет тега</b></td>" );
                fw.Write( @"<td><b>Дублирование школ</b></td>" );
                fw.Write( @"</tr>" );

                fw.WriteLine();
                int n = 0;

                string icon = @"<img border=0 width=16 height=16 src=icon_map.png alt='map' title='Показать на карте'>";

                foreach ( RegionReport rep in reps.Reps )
                {
                    if ( n++ % 2 == 1 )
                        fw.Write( @"<tr>" );
                    else
                        fw.Write( @"<tr class=""clr"">" );

                    fw.Write( @"<td>{0}</td>",
                        Regions.RegionsDict[ rep.Region ] );
                    fw.Write( @"<td>{0:dd-MMM-yyyy}</td>", rep.Stamp );

                    //--------------Ошибки--------------

                    if ( rep.Errors > 0 )
                        fw.Write( @"<td><a href=""{2}"">{3}</a> <a href=""{0}"">{1}</a>",
                            rep.Region + ".html",
                            rep.Errors > 0 ? rep.Errors.ToString() : "",
                            @"map/" + rep.Region + ".errors.map.html",
                            icon
                            );
                    if ( rep.Errors == 0 )
                        fw.Write( @"<td>{0}", "<font color=\"gold\">★</font>" );
                    fw.Write( @" <font color=""{1}"" size=""2.3"">{0}</font></td>",
                    //fw.Write( @" <sup>{0}</sup></td>",
                        rep.ErrorsOld >= 0 && rep.ErrorsOld != rep.Errors ? String.Format( "{0}", ( rep.Errors - rep.ErrorsOld ).ToString( "+#;−#;0" ) ) : "",
                        rep.Errors - rep.ErrorsOld > 0 ? "red" : rep.Errors - rep.ErrorsOld < 0 ? "green" : "black"
                        );

                    //--------------Пред-ния--------------

                    if ( rep.Warnings > 0 )
                        fw.Write( @"<td><a href=""{2}"">{3}</a> <a href=""{0}"">{1}</a>",
                            rep.Region + ".warning.html",
                            rep.Warnings > 0 ? rep.Warnings.ToString() : "",
                            @"map/" + rep.Region + ".warning.map.html",
                            icon
                            );
                    if ( rep.Warnings == 0 )
                        fw.Write( @"<td>{0}", "<font color=\"gold\">★</font>" );
                    fw.Write( @" <font color=""{1}"" size=""2.3"">{0}</font></td>",
                    //fw.Write( @" <sub>{0}</sub></td>",
                        rep.WarningsOld >= 0 && rep.WarningsOld != rep.Warnings ? String.Format( "{0}", ( rep.Warnings - rep.WarningsOld ).ToString( "+#;−#;0" ) ) : "",
                        rep.Warnings - rep.WarningsOld > 0 ? "red" : rep.Warnings - rep.WarningsOld < 0 ? "green" : "black"
                        );

                    //--------------Квартиры--------------

                    if ( rep.Flats > 0 )
                        fw.Write( @"<td><a href=""{0}"">{1}</a>",
                            rep.Region + ".flats.html",
                            rep.Flats > 0 ? rep.Flats.ToString() : ""
                            );
                    if ( rep.Flats == 0 )
                        fw.Write( @"<td>{0}", "<font color=\"gold\">★</font>" );
                    fw.Write( @" <font color=""{1}"" size=""2.3"">{0}</font></td>",
                        rep.FlatsOld >= 0 && rep.FlatsOld != rep.Flats ? String.Format( "{0}", ( rep.Flats - rep.FlatsOld ).ToString( "+#;−#;0" ) ) : "",
                        rep.Flats - rep.FlatsOld > 0 ? "red" : rep.Flats - rep.FlatsOld < 0 ? "green" : "black"
                        );

                    //--------------Нет улицы--------------

                    if ( rep.NoStreet > 0 )
                        fw.Write( @"<td><a href=""{2}"">{3}</a> <a href=""{0}"">{1}</a>",
                            rep.Region + ".nostreet.html",
                            rep.NoStreet > 0 ? rep.NoStreet.ToString() : "",
                            @"map/" + rep.Region + ".nostreet.map.html",
                            icon
                            );
                    if ( rep.NoStreet == 0 )
                        fw.Write( @"<td>{0}", "<font color=\"gold\">★</font>" );
                    fw.Write( @" <font color=""{1}"" size=""2.3"">{0}</font></td>",
                        rep.NoStreetOld >= 0 && rep.NoStreetOld != rep.NoStreet ? String.Format( "{0}", ( rep.NoStreet - rep.NoStreetOld ).ToString( "+#;−#;0" ) ) : "",
                        rep.NoStreet - rep.NoStreetOld > 0 ? "red" : rep.NoStreet - rep.NoStreetOld < 0 ? "green" : "black"
                        );

                    //--------------Нет тега--------------

                    if ( rep.Names > 0 )
                        fw.Write( @"<td><a href=""{2}"">{3}</a> <a href=""{0}"">{1}</a>",
                            rep.Region + ".names.html",
                            rep.Names > 0 ? rep.Names.ToString() : "",
                            @"map/" + rep.Region + ".names.map.html",
                            icon
                            );
                    if ( rep.Names == 0 )
                        fw.Write( @"<td>{0}", "<font color=\"gold\">★</font>" );
                    fw.Write( @" <font color=""{1}"" size=""2.3"">{0}</font></td>",
                        rep.NamesOld >= 0 && rep.NamesOld != rep.Names ? String.Format( "{0}", ( rep.Names - rep.NamesOld ).ToString( "+#;−#;0" ) ) : "",
                        rep.Names - rep.NamesOld > 0 ? "red" : rep.Names - rep.NamesOld < 0 ? "green" : "black"
                        );

                    //--------------Дублирование--------------

                    if ( rep.DoubleSchools > 0 )
                        fw.Write( @"<td><a href=""{2}"">{3} {1}</a>",
                            rep.Region + ".double.html",
                            rep.DoubleSchools,
                            @"map/" + rep.Region + ".double.map.html",
                            icon
                            );
                    if ( rep.DoubleSchools == 0 )
                        fw.Write( @"<td>{0}", "<font color=\"gold\">★</font>" );
                    fw.Write( @" <font color=""{1}"" size=""2.3"">{0}</font></td>",
                        rep.DoubleSchoolsOld >= 0 && rep.DoubleSchoolsOld != rep.DoubleSchools ? String.Format( "{0}", ( rep.DoubleSchools - rep.DoubleSchoolsOld ).ToString( "+#;−#;0" ) ) : "",
                        rep.DoubleSchools - rep.DoubleSchoolsOld > 0 ? "red" : rep.DoubleSchools - rep.DoubleSchoolsOld < 0 ? "green" : "black"
                        );

                    fw.Write( @"</tr>" );
                    fw.WriteLine();
                }

                fw.WriteLine( @"</table>" );
                fw.WriteLine( @"</body></html>" );
            }
        }

        public void SaveMapHtml( FileInfo outfile, List<HouseNumb> lst )
        {
            if ( lst.Count == 0 ) return;

            string indexFile = outfile.FullName;
            string indexBeinFile = @"D:\OSM\ValidatorTT\index_begin.html";
            string indexEndFile = @"D:\OSM\ValidatorTT\index_end.html";

            using ( StreamWriter wr = new StreamWriter( indexFile ) )
            {
                using ( StreamReader rd = new StreamReader( indexBeinFile ) )
                    wr.Write( rd.ReadToEnd() );

                wr.WriteLine( @"map.setView([{0}, {1}], 7);",
                    lst[ 0 ].lat.ToString().Replace( ',', '.' ),
                    lst[ 0 ].lon.ToString().Replace( ',', '.' ) );

                bool cluster = lst.Count > 100 ? true : false;
                bool nostreet = outfile.Name.Split( '.' )[ 1 ] == "nostreet";

                foreach ( var pl in lst )
                {
                    if ( pl.lat == 0 )
                        continue;

                    string popupText = String.Format(
                        @"<a href=\""http://127.0.0.1:8111/load_object?objects={0}{1}\"" onClick=\""open_josm('{0}{1}');return false;\""><img src=icon_to_josm.png></a> "
                        + @"<a href=\""http://osm.org/{0}/{1}\"">{2}</a><br>",
                        pl.Type,
                        pl.Osmid,
                        pl.Hnumb == "" ? "[osm]" : pl.Hnumb.Replace( "\\", "\\\\" ).Replace( "\"", "\\\"" )
                        );

                    string icon = "iErr";

                    if ( nostreet && pl.Description != string.Empty )
                    {
                        foreach ( var place in pl.Description.Split( '|' ) )
                            popupText += place.Replace( ":", " =" ).Replace( "\"", "\\\"" ).Trim();
                        icon = "iWarn";
                    }

                    wr.WriteLine( string.Format( @"L.marker([{0}, {1}],{{icon: {4}}}).addTo({2}).bindPopup(""{3}"");",
                        pl.lat.ToString().Replace( ',', '.' ),
                        pl.lon.ToString().Replace( ',', '.' ),
                        cluster ? "markerCluster" : "map",
                        popupText,
                        icon
                        ) );
                }

                using ( StreamReader rd = new StreamReader( indexEndFile ) )
                    wr.Write( rd.ReadToEnd() );
            }
            
        }

        private void SaveMapAll()
        {
            List<string> types = new List<string>{
                "errors",
                "warning",
                "nostreet",
                "names"
            };

            foreach ( var type in types )
            {
                string indexFile = dirOutMap + "RU." + type + ".map.html";
                string indexBeinFile = @"D:\OSM\ValidatorTT\index_begin.html";
                string indexEndFile = @"D:\OSM\ValidatorTT\index_end.html";
                List<string> errors = new List<string>();

                foreach ( var file in Directory.GetFiles( dirOutMap, "RU-*." + type + ".map.html" ) )
                {
                    using ( StreamReader sr = new StreamReader( file ) )
                    {
                        while ( !sr.EndOfStream )
                        {
                            string line = sr.ReadLine();
                            if ( line.StartsWith( "L.marker" ) )
                                errors.Add( line.Replace( "(map)", "(markerCluster)" ) );
                        }
                    }
                }
                errors = errors.Distinct().ToList();
                using ( StreamWriter wr = new StreamWriter( indexFile ) )
                {
                    using ( StreamReader rd = new StreamReader( indexBeinFile ) )
                        wr.Write( rd.ReadToEnd() );

                    wr.WriteLine( @"map.setView([61.0455502, 83.6036577], 4);" );

                    foreach ( var line in errors )
                        wr.WriteLine( line );

                    using ( StreamReader rd = new StreamReader( indexEndFile ) )
                        wr.Write( rd.ReadToEnd() );
                }
            }
        }
        
        private void UploadToFtp()
        {
            string region = file.Name.Split( '.' )[ 0 ];
            List<string> files = new List<string>{
                "v",
                "",
                "warning",
                "flats",
                "nostreet",
                "names",
                "errors.map",
                "warning.map",
                "nostreet.map",
                "names.map",
                "double.map"
            };


            foreach ( var fl in files )
            {
                string filename = region + "." + fl + ".html";
                if ( fl == "" )
                    filename = region + ".html";
                if ( fl == "v" )
                    filename = "v.html";
                if (fl.EndsWith("map"))
                    filename = @"map/" + region + "." + fl + ".html";

                FileStream fileStream;
                try { fileStream = File.OpenRead( dirOut + filename ); }
                catch ( FileNotFoundException ex ) { continue; }

                FtpWebRequest request = (FtpWebRequest)WebRequest.Create( "ftp://m-tt.ru/http/hnumb/" + filename );
                request.Method = WebRequestMethods.Ftp.UploadFile;
                request.Credentials = new NetworkCredential( "w_m-tt-ru_b9f6e5d2", "fdf7eae9ciop" );
                Stream ftpStream = request.GetRequestStream();

                byte[] buffer = new byte[ 1024 ];
                int bytesRead = 0;
                do
                {
                    bytesRead = fileStream.Read( buffer, 0, 1024 );
                    ftpStream.Write( buffer, 0, bytesRead );
                }
                while ( bytesRead != 0 );
                fileStream.Close();
                ftpStream.Close();
            }
        }

        static void Main( string[] args )
        {
            Program p = new Program();
            p.Validate();
        }
    }
}
